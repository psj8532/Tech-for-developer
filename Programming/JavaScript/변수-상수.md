|                       | var  |       let        |      const       |
| :-------------------: | :--: | :--------------: | :--------------: |
|        스코프         | 함수 |       블록       |       블록       |
|       호이스팅        |  O   |        O         |        O         |
|     선언 전 사용      |  O   | RefferencedError | RefferencedError |
| 선언과 동시에 값 할당 | 선택 |       선택       |       필수       |
|       값 재할당       |  O   |        O         |        X         |
|        재선언         |  O   |        X         |        X         |



## var

#### 스코프

**함수 레벨 스코프**이다.

#### 호이스팅

var은 호이스팅되어 **선언문과 할당문이 분리**되고, **선언문은 스코프의 최상단으로 끌어올려지는 것처럼** 동작한다. 또한, 선언과 동시에 **undefined** 로 초기화하고, 할당문을 만나면 변수에 값이 할당된다. 따라서, 변수 선언 전에 참조해도 에러가 발생하지 않고 undefined가 출력된다.

```javascript
console.log(x); // undefined
var x = 1; // 1
```

#### 할당

선언과 동시에 값을 할당해도 되고, **선언만 먼저하고 값은 나중에 할당해도 된다**. 개발자는 하나의 문으로 작성했으나 자바스크립트 엔진에서 선언문과 할당문은 별개로 인식한다. 따라서 선언문은 호이스팅에 의해 undefined로 초기화된다. 또한, **재할당을 통해 값을 변경**할 수 있고, **재선언도 가능**하다.

```javascript
var x; // undefined
x = 1; // 1

x = 2; // 2
var x = 3; // 3
```



## let

#### 스코프

**블록 레벨 스코프**이다.

#### 호이스팅

<u>ES6에서는 모든 선언을 호이스팅</u>하기 때문에 let과 const도 호이스팅 된다. 하지만 호이스팅이 되지 않는 것처럼 동작한다. 그 이유는 값을 할당하기전까지 참조할 수 없기 때문이다. 다음의 예제를 통해 보자.

```javascript
let x = 0; // 0 // global
{
  console.log(x); // RefferenceError
	let x = 1; // 1 // local
}
```

호이스팅이 되지 않는다면 블록 안에서 x를 참조할 때는 아직 지역 변수 x가 선언되지 않으므로 전역 변수 x를 참조해야한다. 하지만 에러를 출력한다. 이를 통해 지역변수 x의 선언이 호이스팅으로 인해 스코프의 최상단에서 이루어진 것을 알 수 있다. 이 부분까지는 기존 var과 동일하다. 하지만 let과 const는 여기서부터 차이점이 있다.

<u>선언은 스코프의 최상단</u>에서 이루어지지만 var과 달리 undefined로 초기화 하지 않고, <u>선언문이 있는 코드로 와야만 undefined로 초기화되든 값이 할당이 되든 할 수 있다</u>. 즉, 스코프의 상단부터 선언문까지 초기화되지 않았기 때문에 참조할 수 없는 것이다. 이 구간을 **일시적 사각지대(Temporal Dead Zone: TDZ)** 라고 부른다.

#### 할당

선언과 초기화를 반드시 같이 할 필요없다. 또한, **재할당이 가능**하다. 하지만 **재선언은 불가능**하다.



## const

#### 스코프

**블록 레벨 스코프**이다.

#### 호이스팅

let과 동일하게 동작하고, **TDZ**가 존재한다.

#### 할당

**선언과 초기화를 반드시 같이 해야한다.** const는 변수와 반대되는 개념인 **상수**이기 때문에 한번 할당하면 **재할당이 불가능**하다. 또한, immutable한 원시 데이터는 값을 변경할 수 없다. 하지만 **mutable한 배열이나 객체를 할당하면 값을 변경할 수 있다.** 재할당은 불가능하지만 <u>데이터 자체를 변경</u>하는 것이기 때문에 바꿀 수 있는 것이다. 재할당이라고 오해하지않도록 주의해야한다.



## var / let / const

- ES6를 사용한다면 **var**은 사용하지 않는 것이 좋다.

  **버그 발생**과 **메모리 누수**의 위험이 있음

- 기본적으로 **const**를 사용하고, 재할당이 필요한 경우에만 **let**을 사용한다.