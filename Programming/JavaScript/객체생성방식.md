## 객체 리터럴

가장 일반적이고 간단한 객체 생성 방식이다.

```javascript
const obj = {
  a: 10,
	b: 20,  
};

console.log(obj); // {a: 10, b: 20}
```



## Object 생성자 함수

**new Object()**를 이용하여 빈 객체를 생성하는 방식이다.

```javascript
const obj = new Object();

console.log(obj); // {}
```

빈 객체만 생성하기 때문에 객체 리터럴보다 장점이 별로 없기 때문에 추천하지 않는다.



## 생성자 함수

#### 장점

객체 리터럴 방식은 한번 생성하면 끝이다. 따라서 코드를 재사용할 수가 없다. 하지만 생성자 함수를 이용하여 생성할 경우, 인스턴스를 생성하기 위한 템플릿처럼 프로퍼티 구조가 동인한 객체 여러개를 간편하게 만들 수 있다. 따라서, **코드의 재사용**이 가능하다.

#### ※ this

객체 자신의 프로퍼티나 메서드를 참조하기 위한 **자기 참조 변수**이다.

|    함수 호출 방식    |           this가 가리키는 값           |
| :------------------: | :------------------------------------: |
|  일반 함수로서 호출  |               전역 객체                |
|   메서드로서 호출    | 메서드를 호출한 객체(마침표 앞의 객체) |
| 생성자 함수로서 호출 |     생성자 함수가 생성할 인스턴스      |



#### 생성 과정

1. 인스턴스 생성

   자바스크립트 엔진이 런타임 이전에 암묵적으로 **빈 객체를 생성**한다.

2. this 바인딩

   암묵적으로 빈 객체가 생성되면, 이 **인스턴스는 this에 바인딩** 된다.

   여기까지는 코드가 한줄씩 실행되는 런타임 이전에 일어나는 과정이다.

3. 인스턴스 초기화

   생성자 함수에 기술되어 있는 코드가 한 줄씩 실행되어 this에 바인딩되어 있는 **인스턴스를 초기화**한다.

4. 인스턴스 반환

   생성자 함수 내부의 처리가 모두 끝나면 **인스턴스가 바인딩된 this**가 암묵적으로 반환된다.

   만약, 객체를 리턴할 경우엔 객체가 리턴된다. 데이터를 리턴할 경우엔 이 리턴이 무시되고 this가 반환된다.

```javascript
function Circle(r) {
  // 인스턴스 생성 + this 바인딩
  console.log(this); // Circle {}
  
  this.r = r; // 인스턴스 초기화
  this.getDiameter = function() {
    return 2 * this.r;
  };
  
  // 인스턴스 반환
}
const c1 = new Circle(10); // {r: 10, getDiameter: f}
```



#### 내부 메서드

- [[ Call ]]

  **일반 함수**로서 호출할 경우

- [[ Construct ]]

  **생성자 함수**로서 호출할 경우



#### constructor와 non-constructor의 구분

일반 객체는 호출할 수 없지만 함수는 호출할 수 있다. 따라서 함수는 `callable`이어야한다. 또한, `Constructor`이거나 `non-constructor`이다. 

- Constructor : 일반 함수 또는 생성자 함수로서 호출할 수 있는 객체

  함수 선언문, 함수 표현식, 클래스

- Non-constructor : 일반 함수로서만 호출할 수 있는 객체

  메서드(ES6 메서드의 축약 표현만 메서드라 칭함), 화살표 함수

=> `constructor`와 `non-constructor`의 구분은 함수 정의 방식에 따라 정해진다.



#### new 연산자

일반 함수와 생성자 함수에 특별한 형식적 차이가 없다. new 연산자와 함꼐 함수를 호출하면 해당 함수는 생성자로 동작한다. 또한, 구별을 짓기 위해 네이밍 컨벤션은 **파스칼 케이스**를 사용한다.



#### 위험성 회피

##### 방법

- new.target() : ES6

  ```javascript
  function Circle(radius) {
    if (!new.target) {
      return new Circle(radius);
    }
    ...
  }
  ```

  

- instanceof : 스코프 세이프 생성자 패턴

  ```javascript
  function Circle(radius) {
    // 생성자로 호출하지 않았다면 this가 인스턴스에 바인딩 되지 않는다. 따라서 this는 전역 객체를 가리킨다.
    if (this instanceof Circle) {
      return new Circle(radius);
    }
    ...
  }
  ```

##### 빌트인 생성자 함수

대부분의 빌트인 생성자 함수는 new를 사용하지 않아도 new를 사용한 것과 동일하게 동작한다. 하지만 `String`, `Number`, `Boolean` 의 경우엔 new를 사용하지 않는다면 **데이터 타입**을 반환환다.