## 프로세스의 개요

### 프로그램과 프로세스

##### 프로그램

- 저장장치에 저장된 `정적 상태`를 말한다.

- 어떤 데이터를 사용하여 어떤 작업을 하지 `절차` 를 적어 놓은 것이다.

##### 프로세스

- 실행을 위해 메모리에 올라온 `동적 상태`를 말한다.

- 절차를 `실행` 에 옮긴 것이다.



### 프로그램에서 프로세스로의 전환

> 일괄 작업 방식과 시분할 방식이 있지만 대부분 시분할 방식 시스템을 사용한다.

#### 동작 순서

먼저, 운영체제가 프로그램을 메모리로 가져온다. 동시에 작업 지시서의 역할을 하는 프로세스 제어 블록(PCB)을 생성한다.

#### 프로세스 제어 블록

##### 데이터

- 프로세스 구분자(PID)

  - 프로세스를 식별하기 위한 구분자

- 메모리 관련 정보

  - 프로세스의 메모리 위치정보

  - 메모리 보호를위한 `경계`, `한계` 레지스터 포함

- 각종 중간값

  - 프로세스가 중단됐다 다시 실행했을 때 시작 위치를 알기 위해 `프로그램 카운터`를 저장한다.
  - 작업에 대한 정보를 가지고 있는 `다른 레지스터`도 저장한다.

##### 구조

프로세스는 메모리의 사용자 영역에 올라온다. 하지만 PCB는 운영체제가 관리하기 때문에 메모리의 운영체제 영역에 만들어진다.

#### 결론

프로세스는 프로그램이 `메모리`에 올라와 `프로세스 제어 블록`까지 만든 상태이다.



### 프로세스의 상태

#### 활성 상태

##### 생성 상태

프로세스가 메모리에 올라와 실행 준비를 완료한 상태이다. 또한, `프로세스 제어 블록`이 만들어진다.

##### 준비 상태

실행 준비가 완료된 프로세스들이 CPU를 얻을 때까지 기다리는 곳이다. 그리고 CPU 스케줄러에 의해 선택될때까지 기다린다. 선택되면 `dispath(PID)` 가 실행된다.

##### 실행 상태

선택된 프로세스가 배당된 작업 시간인 `타임 슬라이스(타임 퀀텀)` CPU를 사용하는 상태이다. 작업 도중에 시간이 만료되면 timeout(PID)가 실행되어 준비 상태로 돌아가서 차례를 기다린다. 작업이 완료되면 exit(PID)가 실행되어 완료 상태로 이동한다. 

##### 대기 상태

실행 상태의 프로세스가 입출력 관리자에게 요청을하면 입출력이 완료될 때까지 대기 상태에서 기다린다. 이후 완료되면 인터럽트로 프로세스를 찾는 `wakeup(PID)`가 실행되어 준비 상태에 이동한다. 그리고 현재 실행 작업이 끝나면 실행된다. 중간에 하고 있는 작업을 방해하지 않기 위해서다.

##### 완료 상태

프로세스가 종료된 상태이다. 사용했던 코드와 데이터는 메모리에서 삭제하고, 프로세스 제어 블록도 폐기한다. 정상적인 종료는 `exit()`가 실행되지만 오류나 다른 프로세스에 의해 비정상적으로 종료되는 `강제 종료(absort)`를 만나면 디버깅을 위해 강제 종료 직전이 메모리 상태를 저장장치로 옮겨놓는다. 이를 `코어 덤프`라고 한다.

#### 비활성 상태

##### 휴식 상태

프로세스가 작업을 일시적으로 쉬고 있는 상태이다. 실행 도중 `ctrl + z` 키를 눌러 휴식 상태로 만들 수 있다. `jobs`로 확인할 수 있고, `fg`나 `bg`를 이용하여 다시 실행할 수 있다.

##### 보류 상태

프로세스가 메모리에 잠시 쫓겨난 상태로 일시 정지 상태이다. 다음과 같은 경우 보류 상태가 된다.

- 메모리가 꽉 차서 일부 프로세스를 메모리 밖으로 내보낼 때
- 프로그램에 오류가 있어 실행을 미뤄야 할 때
- 바이러스와 같이 악의적인 공격을 하는 프로세스라고 판단될 때
- 매우 긴주기로 반복되는 프로세스라 메모리 밖으로 쫓아내도 큰 문제가 없을 때
- 입출력을 기다리는 프로세스의 입출력이 계속 지연될 때



### 요약

1. 저장장치에 저장된 프로그램을 가져와 메모리에 적재한다. 그리고 프로세스 제어 블록을 생성한다.
2. 준비 상태로 이동한다.
3. CPU 스케줄러에 의해 dispatch 되면 실행 상태로 넘어간다.
4. 실행 상태
   1. 입출력 관리자에게 요청할 경우 이를 처리할 때까지 대기 상태로 이동
      1. 처리가 완료되면 wakeup을 실행하여 프로세스를 깨우고 인터럽트 요청을 보내고 준비상태(2번)로 이동한다
   2. 시간이 만료될 경우 timeout이 실행되어 준비상태(2번)로 이동
   3. 작업이 완료되면 완료 상태로 이동
5. 완료 상태가 되면 사용했던 데이터와 코드를 지우고, 프로세스 제어 블록을 폐기한다.







