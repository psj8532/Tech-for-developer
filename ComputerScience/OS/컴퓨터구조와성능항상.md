## 컴퓨터의 기본 구성

### 하드웨어의 구성

##### 필수 장치

- 중앙 처리 장치 (CPU)
- 메인 메모리 (제 1 저장 장치): 전력이 끊기면 데이터 휘발

##### 주변 장치

- 입출력 장치
- 저장 장치 (제 2 저장 장치)



### 폰 노이만 구조

- 장치들이 버스로 연결된 구조

- 작업하고 싶은 프로그램을 메모리에 올려 사용

=> 모든 프로그램은 메모리에 올라와야 실행할 수 있다.



### 하드웨어 사양 관련 용어

##### 클록 (clock)

- `CPU`의 속도를 나타내는 단위
- 클록이 일정 각격으로 펄스를 보내면 이 신호에 맞춰 모든 구성 부품이 작업 진행

##### 헤르츠 (Hz)

- `펄스`가 발생하는 속도
- 1초에 펄스가 몇번 발생하는지를 나타낸다. 
- ex) 60Hz => 1초에 펄스 60회 발생

##### 시스템 버스

- 메모리와 주변 장치를 연결하는 버스 (FSB, Front- Side Bus)

  ※일반적으로 메인보드의 시스템 버스 속도에 맞춘 메모리 속도를 사용한다. 메모리 속도가 시스템 버스의 속도보다 느릴 경우 시스템 버스 속도도 느려져 성능이 저하된다.

##### CPU 내부 버스

- CPU 내부의 장치를 연결하는 버스 (BSB, Back-Side Bus)
- CPU의 클록과 같은 속도이므로 시스템 버스 보다 빠르다.



## CPU와 메모리

### CPU의 구성과 동작

#### 기본 구성

>  명령어를 해석하여 실행하는 장치

- 산술논리 연산장치
  - 데이터 연산
  - AND, OR 등의 논리 연산
- 제어장치
  - 작업 지시
- 레지스터
  - CPU 내에 데이터를 임시 보관

#### 명령어 처리 과정

1. 필요한 데이터를 메모리에서 가져와 레지스터에 저장
2. 산술 논리 연산 장치에서 레지스터에 있는 데이터 추출
3. 연산 수행
4. 연산 결과를 레지스터에 저장
5. 레지스터에 있는 데이터를 메모리에 저장



### 레지스터의 종류

#### 사용자 가시 레지스터

- 데이터 레지스터(DR)
  - 메모리에서 가져온 `데이터`를 임시 보관
  - `일반 레지스터`, `범용 레지스터`라고도 불림
- 주소 레지스터(AR)
  - 데이터 또는 명령어가 저장된 `메모리 주소` 저장

#### 사용자 불가시 레지스터 (특수 레지스터)

- 프로그램 카운터(PC)
  - `다음 실행할 명령어`의 주소 기억
- 명령어 레지스터(IR)
  - `현재 실행중인 명령어` 저장
  - 제어 장치는 IR에 있는 명령어를 해석하여 제어

- 메모리 주소 레지스터 (MAR)
  - 메모리에서 데이터를 가져오거나 보낼때, 메모리의 <u>어느 주소로 접근할지</u> 정보를 가지고 있다.

- 메모리 버퍼 레지스터(MBR)
  - 메모리에서 가져온 데이터나 보낼 <u>데이터를 임시 저장</u>
  - 항상 메모리 주소 레지스터와 같이 저장



### 버스의 종류

#### 제어버스

- `제어 장치`와 연결
- CPU가 메모리와 주변장치에 제어 신호를 보내기 위해 사용

#### 주소 버스

- `메모리 주소 레지스터`와 연결
- 단방향 (CPU로 주소를 보낼일이 없기 때문이다.)

#### 데이터 버스

- `메모리 버퍼 레지스터`와 연결
- 데이터 이동
- 양방향
- 버스의 대역폭(Band Width)
  - 한 번에 전달할 수 있는 데이터의 최대 크기 (1word)
  - 32bit CPU => 1word = 32bit / 64bit CPU => 1word = 64bit



### 메모리의 종류와 부팅

#### 종류

##### 램(RAM)

- 휘발성
  - DRAM
    - 일정 시간 지나면 휘발 => Refresh 필요
    - 메인 메모리에 사용
  - SRAAM
    - 전력이 끊기면 휘발
    - 속도가 빠르고 고가
    - 캐시 메모리에 사용
  - SDRAM
- 비휘발성
  - 플래시 메모리
  - FRAM
  - PRAM

##### 롬(ROM)

- 마스크롬
  - 데이터 쓰기, 삭제 불가

- PROM
  - 데이터 한 번 저장할 수 있다. (전용기계 필요)
- EPROM
  - 데이터 쓰기, 삭제 가능 (여러번)



#### 메모리 보호

> 다른 작업의 메모리 영역에 침범하는 것을 방지하기 위해 하드웨어적으로 검사하여 보호

1. 데이터를 읽고 쓰는 작업이 진행 될떄, `경계`, `한계` 레지스터 내에서 이루어지는지 검사
2. 벗어나면 CPU에 `인터럽트` 요청
3. 운영체제가 해당 프로그램을 `강제 종료`함으로써 보호

※ 경계 레지스터, 한계 레지스터

​	경계: 레지스터의 시작 주소

​	한계: 주소의 크기



## 컴퓨터 성능 향상 기술

CPU 속도가 다른 주변 장치에 비해 빠르기 때문에 속도 차이가 발생한다. 이런 차이를 개선하는 기술에 대해 알아보자.

### 버퍼

#### 개념

속도 차이가 있는 두 장치에서 차이를 완화하는 역할

(그림)

#### 스풀

CPU와 입출력 장치가 독립적으로 동작하도록 고안된 소프트웨어적인 버퍼

#### 캐시

##### 개념

- 미래에 사용할 확률이 높은 데이터를 미리 가져와 저장해두는 임시 장소

- 데이터가 캐시에 있을 경우 => cache hit

- 없을 경우 => cache miss

=> 메모리와 CPU 간 속도 차이 완화



##### 데이터 반영

> 캐시에 있는 데이터가 변경된 것은 메모리에 있는 원본이 변경된 것이 아니므로 별도로 반영하는 직업이 필요

- 즉시 쓰기 정책 (write throw)
  - 변경되는 즉시 메모리에도 반영
  - 갑자기 전원이 끊겨도 메모리에 데이터가 저장됐기 때문에 데이터가 유지된다.
  - 빈번한 전송으로 인해 성능 저하
- 지연 쓰기 정책 (write back)
  - 변경된 내용을 모아 주기적으로 반영
  - 메모리와 캐시의 데이터가 상이할 수 있다.
  - 전송 횟수가 줄어 성능 향상



### 저장 장치의 계층 구조

##### 컴퓨터의 성능을 향상하기 위한 방안

- 느린 하드 디스크 대신 SSD 같은 빠른플래시 메모리 사용
- 메모리를 하드디스크 크기만큼 확장
- 캐시를 크게 늘려 캐시 적중률 향상

=> 위 방법들은 비용이 많이 들기 때문에 현실적으로 한계가 있다. 따라서 계층 구조를 이용함으로써 해결할 수 있다.

##### 해결 방법

계층 구조에서 CPU에 가까울수록 비싸고 빠른 부품을 사용하고, 멀어질수록 싸고 느린 부품을 사용한다. 이를 통해 큰 용량과 빠른 속도라는 두가지 토끼를 잡을 수 있다.

##### (그림)



### 인터럽트

기존에는 CPU가 `폴링` 방식을 이용했다. 하지만 최근 주변 장치가 많아짐에 따라 CPU가 성능 이슈 문제로 모든 입출력에 관여할 수 없게 됐다. 그래서 인터럽트 개념을 도입하여 해결했다. 인터럽트는 **CPU의 작업**과 **저장장치의 데이터 이동**을 **독립적으로 운영**함으로써 <u>시스템의 효율을 높일 수 있다</u>.

※ 폴링이란?

​	CPU가 직접 입출력장치에서 데이터를 가져오거나 보내는 방식이다.

##### 동작 과정

1. CPU가 입출력 관리자에게 입출력 명령을 보낸다.
2. 입출력 관리자는 명령받은 데이터를 메모리에 가져다놓거나 메모리에 있는 데이터를 저장장치로 옮긴다.
3. 데이터 전송이 완료되면 입출력 관리자는 완료 신호(인터럽트)를 CPU에 보낸다.
4. 인터럽트 신호를 받은 CPU는 `컨텍스트 스위칭을 진행하고 다음 작업을 처리한다.

※ 컨텍스트 스위칭(Context Switching)이란?

CPU가 기존 작업을 진행 중이던 상태에서 인터럽트 요청에 의해 다음 우선 순위의 작업을 진행해야할 때, 기존 작업을 중단하고 저장한 후, 다음 작업을 할 수 있도록 교체해주는 작업을 말한다.

##### 메모리 접근 권한

메모리나 주변장치에 대한 모든 권한은 CPU에게만 있다. 따라서 입출력 관리자가 데이터를 조회하거나 쓸 경우 CPU로부터 권한을 받아야한다.

- 직접 메모리 접근 (DMA, Direct Memory Access)

  - CPU 허락 없이 메모리에 접근할 수 있는 권한 부여

  - 메모리가 복잡해질 수 있다.

    메모리는 CPU와 입출력 장치가 각각 사용하는 데이터가 섞여 있다. 들어오는 데이터를 아무렇게 둔다면 관리하기 어려워진다. 따라서, `메모리 매핑 입출력` 기법을 추가하여 사용해야한다.

- 메모리 매핑 입출력 (MMIO, Memory Mapped I/O)
  - DMA의 단점을 보완하고자 같이 사용하는 기법
  - `CPU`가 사용하는 메모리 공간과 `직접 메모리 접근`을 통해 들어오거나 나가는 데이터를 위한 공간을 분리

##### 사이클 훔치기

`CPU`와 `직접 메모리 접근`이 동시에 이루어질 경우, 누군가는 양보를 해야한다. 보통 CPU가 양보한다. 그 이유는 CPU의 작업 속도보다 입출력장치 속도가 더 빠르기 때문이다. 직접 메모리 접근의 입장에서 보면 사이클을 훔친 것이기 때문에 사이클 훔치기라고 한다.



## 병렬 처리

### CPU의 성능을 향상하는 방법

- CPU의 `클록`을 높이다.

  => `발열`이 높아진다.

- `캐시`의 크기를 늘린다.

  => 너무 비싸다.

이러한 문제를 해결하기 위해 병렬 처리 방법을 사용한다. 병렬 처리 방법은 여러개의 명령을 동시에 처리하여 작업의 능률을 높인다.



### 고려 사항

- `상호 의존성`을 없애야 한다.

  각 명령이 서로 독립적이고 앞의 결과가 뒤에 명령에 영향을 미치지 않아야한다.

- 각 단계의 `시간을 일정하게` 맞춰야한다.

  일정하지 않을 경우 **병목 현상** 발생

- 전체 작업 시간을 몇 단계로 나눌지 잘 판단해야 한다.

  - 병렬 처리의 깊이(depth of parallel processing) : 쪼갠 작업의 갯수

    최적의 병렬처리 깊이는 `10~20`이다. 너무 많이 부르면 새 작업을 불러오는데 시간이 오래 걸려 오버헤드를 초래하기 때문이다.



### 병렬 처리 기법

#### 명령어 실행 과정

1. 명령어 패치(IF, Instruction Fetch)

   다음 실행할 명령어를 명령어 레지스터에 저장

2. 명령어 해석(ID, Instruction Decode)

   명령어 해석

3. 실행(EX, EXecution)

   해석 결과 바탕으로 명령어 실행

4. 쓰기(WB, Write Back)

   실행 결과 메모리 저장



#### 파이프라인 기법

> 하나의 코어에서 작업을 나누어 병렬로 처리

- 하이퍼 스레드라고도 불린다. 

- 각 단계는 독립적으로 구성

- 파이프라인의 위험 존재

  - 데이터 위험

    데이터 의존성 때문에 발생 => 파이프라인의 **명령어 단계를 지연**하여 해결

  - 제어 위험

    goto 등으로 프로그램 카운터(pc) 값이 갑자기 변하면 발생 => **분기 예측**, **분기 지연** 방법으로 해결

  - 구조 위험

    서로 다른 명령어가 같은 자원에 접근할 때 발생 => 해결이 어렵다.



#### 슈퍼스칼라 기법

> 복수의 코어를 구성하여 복수의 명령어를 동시에 실행하는 방법

- 독립적으로 구성
- 컴파일러에서 명령어 처리



#### 슈퍼파이프라인 기법

> 한 클록 내에 여러 개의 명령을 처리하는 방식

- 기존 파이프라인은 한 클록에 하나의 명령어만 실행했지만 슈퍼 파이프라인은 여러 명령어 처리 가능



#### 슈퍼파이프라인 슈퍼스칼라 기법

> 여러개의 코어로 돌리면서, 한 클록 내에 여러개의 명령어를 처리할 수 있다.

- 슈퍼파이프라인 + 슈퍼 스칼라



#### VLIW(Very Long Instruction Word) 기법

> 소프트웨어적으로 병렬 처리

- 동시에 수행할 수 있는 명령어 => 컴파일러가 추출 => 하나의 명령어로 압축 => 실행

- 동시에 처리하는 명령어의 갯수가 적다.

  CPU가 병렬 처리를 지원하지 않을 때 사용하는 방법이기 때문이다.



#### 참고

쉽게 배우는 운영체제(한빛아카데미)