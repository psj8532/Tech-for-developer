## 프로세스의 개요

### 프로그램과 프로세스

##### 프로그램

- 저장장치에 저장된 `정적 상태`를 말한다.

- 어떤 데이터를 사용하여 어떤 작업을 하지 `절차` 를 적어 놓은 것이다.

##### 프로세스

- 실행을 위해 메모리에 올라온 `동적 상태`를 말한다.

- 절차를 `실행` 에 옮긴 것이다.



### 프로그램에서 프로세스로의 전환

> 일괄 작업 방식과 시분할 방식이 있지만 대부분 시분할 방식 시스템을 사용한다.

#### 동작 순서

먼저, 운영체제가 프로그램을 메모리로 가져온다. 동시에 작업 지시서의 역할을 하는 프로세스 제어 블록(PCB)을 생성한다.

#### 프로세스 제어 블록

##### 데이터

- 프로세스 구분자(PID)

  - 프로세스를 식별하기 위한 구분자

- 메모리 관련 정보

  - 프로세스의 메모리 위치정보

  - 메모리 보호를위한 `경계`, `한계` 레지스터 포함

- 각종 중간값

  - 프로세스가 중단됐다 다시 실행했을 때 시작 위치를 알기 위해 `프로그램 카운터`를 저장한다.
  - 작업에 대한 정보를 가지고 있는 `다른 레지스터`도 저장한다.

##### 구조

프로세스는 메모리의 사용자 영역에 올라온다. 하지만 PCB는 운영체제가 관리하기 때문에 메모리의 운영체제 영역에 만들어진다.

#### 결론

프로세스는 프로그램이 `메모리`에 올라와 `프로세스 제어 블록`까지 만든 상태이다.



### 프로세스의 상태

#### 활성 상태

##### 생성 상태

프로세스가 메모리에 올라와 실행 준비를 완료한 상태이다. 또한, `프로세스 제어 블록`이 만들어진다.

##### 준비 상태

실행 준비가 완료된 프로세스들이 CPU를 얻을 때까지 기다리는 곳이다. 그리고 CPU 스케줄러에 의해 선택될때까지 기다린다. 선택되면 `dispath(PID)` 가 실행된다.

##### 실행 상태

선택된 프로세스가 배당된 작업 시간인 `타임 슬라이스(타임 퀀텀)` CPU를 사용하는 상태이다. 작업 도중에 시간이 만료되면 timeout(PID)가 실행되어 준비 상태로 돌아가서 차례를 기다린다. 작업이 완료되면 exit(PID)가 실행되어 완료 상태로 이동한다. 

##### 대기 상태

실행 상태의 프로세스가 입출력 관리자에게 요청을하면 입출력이 완료될 때까지 대기 상태에서 기다린다. 이후 완료되면 인터럽트로 프로세스를 찾는 `wakeup(PID)`가 실행되어 준비 상태에 이동한다. 그리고 현재 실행 작업이 끝나면 실행된다. 중간에 하고 있는 작업을 방해하지 않기 위해서다.

##### 완료 상태

프로세스가 종료된 상태이다. 사용했던 코드와 데이터는 메모리에서 삭제하고, 프로세스 제어 블록도 폐기한다. 정상적인 종료는 `exit()`가 실행되지만 오류나 다른 프로세스에 의해 비정상적으로 종료되는 `강제 종료(absort)`를 만나면 디버깅을 위해 강제 종료 직전이 메모리 상태를 저장장치로 옮겨놓는다. 이를 `코어 덤프`라고 한다.

#### 비활성 상태

##### 휴식 상태

프로세스가 작업을 일시적으로 쉬고 있는 상태이다. 실행 도중 `ctrl + z` 키를 눌러 휴식 상태로 만들 수 있다. `jobs`로 확인할 수 있고, `fg`나 `bg`를 이용하여 다시 실행할 수 있다.

##### 보류 상태

프로세스가 메모리에 잠시 쫓겨난 상태로 일시 정지 상태이다. 다음과 같은 경우 보류 상태가 된다.

- 메모리가 꽉 차서 일부 프로세스를 메모리 밖으로 내보낼 때
- 프로그램에 오류가 있어 실행을 미뤄야 할 때
- 바이러스와 같이 악의적인 공격을 하는 프로세스라고 판단될 때
- 매우 긴주기로 반복되는 프로세스라 메모리 밖으로 쫓아내도 큰 문제가 없을 때
- 입출력을 기다리는 프로세스의 입출력이 계속 지연될 때



### 동작 과정(요약)

1. 저장장치에 저장된 프로그램을 가져와 메모리에 적재한다. 그리고 프로세스 제어 블록을 생성한다.
2. 준비 상태로 이동한다.
3. CPU 스케줄러에 의해 dispatch 되면 실행 상태로 넘어간다.
4. 실행 상태
   1. 입출력 관리자에게 요청할 경우 이를 처리할 때까지 대기 상태로 이동
      1. 처리가 완료되면 wakeup을 실행하여 프로세스를 깨우고 인터럽트 요청을 보내고 준비상태(2번)로 이동한다
   2. 시간이 만료될 경우 timeout이 실행되어 준비상태(2번)로 이동
   3. 작업이 완료되면 완료 상태로 이동
5. 완료 상태가 되면 사용했던 데이터와 코드를 지우고, 프로세스 제어 블록을 폐기한다.



### 문맥 교환(Context Switching)

CPU가 프로세스를 점유하고 있는 상태에서 프로세스에게 주어진 시간이 만료됐거나 인턴럽트 요청이 걸리면 발생한다. **컨텍스트 스위칭**은 기존 프로세스에 대한 정보를 프로그램 카운터에 저장하고 다음 프로세스의 상태를 가져와서 작업을 진행하도록 교체하는 작업을 말한다.. 작업이 완료되면 프로그램 카운터에 저장된 작업으로 전환하여 계속 진행한다



## 프로세스의 연산

### 프로세스의 구조

프로세스는 **코드**, **데이터**, **스택** 영역으로 구성된다. 그리고 데이터 영역은 `일반 데이터` 영역과 `힙` 영역으로 나뉜다.

##### 코드 영역(요리책)

- 프로그램의 본문이 기술된 곳이다. 텍스트 영역이라고도 불린다.
- 프로그래머가 작성한 코드가 읽기 전용으로 탑재된다. 읽기 전용으로만 탑재되는 이유는 프로그램이 자기 자신을 수정하지는 않기-  때문이다.

##### 데이터 영역(재료)

- 코드가 실행되면서 사용하는 <u>변수나 파일의 데이터</u>가 저장되는 곳이다.
- 데이터는 변하는 값이기 때문에 읽기와 쓰기 모두 가능하다. 단, 상수의 경우는 읽기 전용이다.

##### 스택 영역(조리도구)

- 운영체제가 프로세스를 실행하기 위해 부수적으로 필요한 데이터를 모아놓은 곳이다.
- 예를 들어, 함수 수행 후 되돌아올 위치를 이 영역에 저장한다.
- 운영체제가 프로세스의 작동을 유지하기 위해 사용하는 것이므로 사용자에게는 보이지 않는다.



### 프로세스의 생성과 복사

> fork ()

프로세스는 프로그램을 실행할 때 새로 생성된자. 하지만 같은 프로세스를 처리해야할 때 매번 새로 생성한다면 효율성이 떨어진다. 그래서 `복제`하는 방법(`fork()`)을 활용할 수 있다.

##### 개념

- fork() 시스템 호출은 실행 중인프로세스로 부터 새로운 프로세스를 `복사`하는 함수이다. 

- 실행 중인 프로세스는 `부모` 프로세스, 새로 생긴 프로세스는 `자식` 프로세스가 되어 `부모-자식 관계`가 된다.

- 변경 되는 데이터

  - 프로세스 구분자(PID)

  - 메모리 관련 정보

  - 부모 프로세스 구분자(PPID)와 자식 프로세스 구분자(CPID)

    새로 생긴 프로세스는 자식 프로세스가 없으므로 CPID가 -1이다.

- 부모 프로세스와 자식 프로세스는 독립적으로 동작하기 때문에 어느 프로세스가 먼저 끝날지는 알 수 없다.

##### 장점

- 프로세스의 생성 속도가 빠르다.

  하드디스크로부터 프로그램을 새로 가져오는 것이 아니라 기존 메모리에서 복사하기 때문이다.

- 추가 작업 없이 자원을 상속할 수 있다.

  부모 프로세서가 사용하던 모든 자원을 바로 상속 받을 수 있다.

- 시스템 관리를 효율적으로 할 수 있다.

  부모-자식 관계이기 때문에 자식프로세스가 종료되면 자식이 사용하던 자원을 부모 프로세스가 정리 할 수 있다. 이를 통해, 프로세스가 사용하던 `메모리 영역`, `파일`, `하드웨어`를 잘 정리할 수 있다.



### 프로세스의 전환

> exec ()

fork()를 사용하면 빠르게 새로운 프로세스를 복사해올 수 있다. 만약 새로운 프로세스의 작업에서 다른 작업을 하고 싶을 경우에는 exec()를 사용하면 된다.

##### 개념

- 기존 프로세스를 새로운 프로세스로 전환하는 함수이다.
- 새로운 코드 영역만 가져오면 되기 때문에 운영체제의 작업이 수월하다.
- 이미 만들어진 프로세스의 구조를 재활용하는 것이다.

##### 동작 과정

1. `exec()` 시스템 호출

2. 코드 영역에 있는 기존 내용을 지우고 `새로운 코드`로 바꾼다.

3. 데이터 영역이 새로운 변수로 채워지고 `스택 영역이 리셋`된다.

   PID,PPID,CPID, 메모리 관련 사항은 변하지 않지만, PC를 비롯한 각종 레지스터와 사용한 파일 정보가 모두 리셋된다.

`fork()` 와 `exec()` 를 잘 활용하면 시스템 효율을 높일 수 있다.



### 프로세스의 계층 구조

##### 장점

- 여러 작업의 동시 처리

  여러명이 동시에 login하려고 할 때, login 프로세스는 한 번에 1명만 처리할 수 있다. 따라서, fork를 이용해서 login 프로세스를 여러개 만들어 나눠줌으로써 동시에 처리할 수 있다. 그리고 login 프로세스가 완료되면 exec를 이용하여 login 프로세스의 구조를 shell 프로세스로 재활용한다. 이를 통해 자원을 효율적으로 관리 할 수 있다.

- 용이한 자원 회수

  프레세스 간의 책임 관계가 분명해져서 시스템 관리에 용이하다. 프로세스가 독립적이라면 종료될 때마다 운영체제가 직접 자원을 회수해야한다. 하지만 부모-자식 관계에서는 자식 프로세스가 종료됐을 때 부모 프로세스가 회수하면 된다.

##### 고아 프로세스

- 부모 프로세스가 자식 프로세스보다 먼저 종료된 상태

##### 좀비 프로세스

- 자식 프로세스가 종료 했음에도 부모가 자원을 회수하지 않는 상태

=> 고아 프로세스와 좀비 프로세스가 많아지면 자원이 낭비되어 효율적인 운영에 방해된다. 또한, 운영체제가 자원 회수를 주기적으로 해야 한다. main함수의 맨 마지막에 exit나 return 문을 쓰는 것도 부모 프로세스에게 종료을 알려 좀비 프로세스가 되는 것을 방지하기 위한 것이다.